{"version":3,"names":[],"mappings":"","sources":["base-model.js"],"sourcesContent":["\n(function() {\n\n\tvar cbVar;\n\n\tvar MASK = 0xffff;   // unreachable position\n\tvar FLAG_MOVE = 0x10000; // move to if target pos empty\n\tvar FLAG_CAPTURE = 0x20000; // capture if occupied by enemy\n\tvar FLAG_STOP = 0x40000; // stop if occupied\n\tvar FLAG_SCREEN_CAPTURE = 0x80000; // capture if occupied by and a piece has been jumped in the path (like cannon in xiangqi) \n\tvar FLAG_CAPTURE_KING = 0x100000; // capture if occupied by enemy king\n\tvar FLAG_CAPTURE_NO_KING = 0x200000; // capture if not occupied by enemy king\n\tModel.Game.cbConstants = {\n\t\tMASK: MASK,\n\t\tFLAG_MOVE: FLAG_MOVE,\n\t\tFLAG_CAPTURE: FLAG_CAPTURE,\n\t\tFLAG_STOP: FLAG_STOP,\n\t\tFLAG_SCREEN_CAPTURE: FLAG_SCREEN_CAPTURE,\n\t\tFLAG_CAPTURE_KING: FLAG_CAPTURE_KING,\n\t\tFLAG_CAPTURE_NO_KING: FLAG_CAPTURE_NO_KING,\n\t}\n\tvar USE_TYPED_ARRAYS = typeof Int32Array != \"undefined\";\n\t\n\tModel.Game.cbUseTypedArrays = USE_TYPED_ARRAYS; \n\n\tModel.Game.cbTypedArray = function(array) {\n\t\tif(USE_TYPED_ARRAYS) {\n\t\t\tvar tArray=new Int32Array(array.length);\n\t\t\ttArray.set(array);\n\t\t\treturn tArray;\n\t\t} else {\n\t\t\tvar arr=[];\n\t\t\tvar arrLength=array.length;\n\t\t\tfor(var i=0;i<arrLength;i++)\n\t\t\t\tarr.push(array[i]);\n\t\t\treturn arr;\n\t\t}\n\t}\n\n\tModel.Game.cbShortRangeGraph = function(geometry,deltas,confine,flags) {\n\t\tvar $this=this;\n\t\tif(flags===undefined)\n\t\t\tflags = FLAG_MOVE | FLAG_CAPTURE;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tif(confine && !(pos in confine))\n\t\t\t\tcontinue;\n\t\t\tdeltas.forEach(function(delta) {\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null && (!confine || (pos1 in confine))) \n\t\t\t\t\tgraph[pos].push($this.cbTypedArray([pos1 | flags]));\t\t\t\t\t\t\t\t\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbLongRangeGraph = function(geometry,deltas,confine,flags,maxDist) {\n\t\tvar $this=this;\n\t\tif(flags===undefined || flags==null)\n\t\t\tflags=FLAG_MOVE | FLAG_CAPTURE;\n\t\tif(!maxDist)\n\t\t\tmaxDist=Infinity;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tif(confine && !(pos in confine))\n\t\t\t\tcontinue;\n\t\t\tdeltas.forEach(function(delta) {\n\t\t\t\tvar direction=[];\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tvar dist=0;\n\t\t\t\twhile(pos1!=null) {\n\t\t\t\t\tif(confine && !(pos1 in confine))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdirection.push(pos1 | flags);\n\t\t\t\t\tif(++dist==maxDist)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpos1=geometry.Graph(pos1,delta);\n\t\t\t\t}\n\t\t\t\tif(direction.length>0)\n\t\t\t\t\tgraph[pos].push($this.cbTypedArray(direction));\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbNullGraph = function(geometry) {\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos]=[];\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbAuthorGraph = function(geometry) {\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tfor(var pos1=0;pos1<geometry.boardSize;pos1++)\n\t\t\t\tgraph[pos].push([pos1|FLAG_MOVE|FLAG_CAPTURE|FLAG_CAPTURE_NO_KING])\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbMergeGraphs = function(geometry) {\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos] = [];\n\t\t\tfor(var i=1;i<arguments.length;i++)\n\t\t\t\tgraph[pos] = graph[pos].concat(arguments[i][pos]);\n\t\t}\n\t\treturn graph;\n\t}\n\n\tModel.Game.cbGetThreatGraph = function() {\n\t\tvar $this=this;\n\t\t\n\t\tthis.cbUseScreenCapture=false;\n\t\tthis.cbUseCaptureKing=false;\n\t\tthis.cbUseCaptureNoKing=false;\n\t\tvar threatGraph={\n\t\t\t'1': [],\n\t\t\t'-1': [],\n\t\t};\n\n\t\tvar lines=[];\n\t\tfor(var pos=0;pos<this.g.boardSize;pos++) {\n\t\t\tthis.g.pTypes.forEach(function(pType,typeName) {\n\t\t\t\tpType.graph[pos].forEach(function(line1) {\n\t\t\t\t\tvar line=[];\n\t\t\t\t\tfor(var i=0;i<line1.length;i++) {\n\t\t\t\t\t\tvar tg1=line1[i];\n\t\t\t\t\t\tif(tg1 & FLAG_CAPTURE_KING) {\n\t\t\t\t\t\t\t$this.cbUseCaptureKing=true;\n\t\t\t\t\t\t\tline.unshift({d:tg1 & MASK,a:pos,tk:typeName});\n\t\t\t\t\t\t} else if(tg1 & FLAG_CAPTURE_NO_KING) {\n\t\t\t\t\t\t\t$this.cbUseCaptureNoKing=true;\n\t\t\t\t\t\t\tline.unshift({d:tg1 & MASK,a:pos,tnk:typeName});\n\t\t\t\t\t\t} else if(tg1 & FLAG_CAPTURE)\n\t\t\t\t\t\t\tline.unshift({d:tg1 & MASK,a:pos,t:typeName});\n\t\t\t\t\t\telse if(tg1 & FLAG_STOP)\n\t\t\t\t\t\t\tline.unshift({d:tg1 & MASK,a:pos});\n\t\t\t\t\t\telse if(tg1 & FLAG_SCREEN_CAPTURE) {\n\t\t\t\t\t\t\t$this.cbUseScreenCapture=true;\n\t\t\t\t\t\t\tline.unshift({d:tg1 & MASK,a:pos,ts:typeName});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(line.length>0)\n\t\t\t\t\t\tlines.push(line);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tvar allAttackers={};\n\n\t\tlines.forEach(function(line) {\n\t\t\tline.forEach(function(lineItem,lineIndex) {\n\t\t\t\tvar attackers=allAttackers[lineItem.d];\n\t\t\t\tif(attackers===undefined) {\n\t\t\t\t\tattackers={};\n\t\t\t\t\tallAttackers[lineItem.d]=attackers;\n\t\t\t\t}\n\t\t\t\tvar poss=[];\n\t\t\t\tfor(var i=lineIndex+1;i<line.length;i++)\n\t\t\t\t\tposs.push(line[i].d);\n\t\t\t\tposs.push(lineItem.a);\n\t\t\t\tvar key=poss.join(\",\");\n\t\t\t\tvar att0=attackers[key];\n\t\t\t\tif(att0===undefined) {\n\t\t\t\t\tatt0={\n\t\t\t\t\t\tp: poss,\n\t\t\t\t\t\tt: {},\n\t\t\t\t\t\tts: {},\n\t\t\t\t\t\ttk: {},\n\t\t\t\t\t}\n\t\t\t\t\tattackers[key]=att0;\n\t\t\t\t}\n\t\t\t\tif(lineItem.t!==undefined)\n\t\t\t\t\tatt0.t[lineItem.t]=true;\n\t\t\t\telse if(lineItem.tk!==undefined)\n\t\t\t\t\tatt0.tk[lineItem.tk]=true;\n\t\t\t\telse if(lineItem.ts!==undefined)\n\t\t\t\t\tatt0.ts[lineItem.ts]=true;\n\t\t\t});\n\t\t});\n\t\t\n\t\tfor(var pos=0;pos<$this.g.boardSize;pos++) {\n\t\t\tvar attackers=allAttackers[pos];\n\t\t\t\n\t\t\tfunction Compact(tree,base) {\n\t\t\t\tfor(var i in attackers) {\n\t\t\t\t\tvar attacker=attackers[i];\n\t\t\t\t\tif(attacker.p.length<base.length+1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar candidate=true;\n\t\t\t\t\tfor(var j=0;j<base.length;j++)\n\t\t\t\t\t\tif(base[j]!=attacker.p[j]) {\n\t\t\t\t\t\t\tcandidate=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif(!candidate)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar nextPos=attacker.p[base.length];\n\t\t\t\t\tvar nextBranch=tree[nextPos];\n\t\t\t\t\tif(nextBranch===undefined) {\n\t\t\t\t\t\tnextBranch={e:{}};\n\t\t\t\t\t\ttree[nextPos]=nextBranch;\n\t\t\t\t\t}\n\t\t\t\t\tif(attacker.p.length==base.length+1) {\n\t\t\t\t\t\tnextBranch.t=attacker.t;\n\t\t\t\t\t\tnextBranch.ts=attacker.ts;\n\t\t\t\t\t\tnextBranch.tk=attacker.tk;\n\t\t\t\t\t\tdelete attackers[i];\n\t\t\t\t\t}\n\t\t\t\t\t//Compact(nextBranch.e,base.concat([nextPos]));\n\t\t\t\t\tbase.push(nextPos);\n\t\t\t\t\tCompact(nextBranch.e,base);\n\t\t\t\t\tbase.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar tree={};\n\t\t\tCompact(tree,[]);\n\t\t\t\n\t\t\tthreatGraph[1][pos]=tree;\n\t\t\tthreatGraph[-1][pos]=tree;\n\t\t}\n\n\t\treturn threatGraph;\n\t}\n\t\n\tModel.Game.InitGame = function() {\n\t\tvar $this=this;\n\t\tthis.cbVar = cbVar = this.cbDefine();\n\t\t\n\t\tthis.g.boardSize = this.cbVar.geometry.boardSize;\n\n\t\tthis.g.pTypes = this.cbGetPieceTypes();\n\t\tthis.g.threatGraph = this.cbGetThreatGraph();\n\t\tthis.g.distGraph = this.cbVar.geometry.GetDistances();\n\t\t\n\t\tthis.cbPiecesCount = 0;\n\t\t\n\t\tthis.g.castleablePiecesCount = { '1': 0, '-1': 0 };\n\t\tfor(var i in cbVar.pieceTypes) {\n\t\t\tvar pType=cbVar.pieceTypes[i];\n\t\t\tif(pType.castle) {\n\t\t\t\tvar initial=pType.initial || [];\n\t\t\t\tinitial.forEach(function(iniPiece) {\n\t\t\t\t\t$this.g.castleablePiecesCount[iniPiece.s]++;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(pType.initial)\n\t\t\t\tthis.cbPiecesCount += pType.initial.length; \n\t\t}\n\n\t\tvar boardValues=[];\n\t\tfor(var i=0;i<this.cbPiecesCount;i++) \n\t\t\tboardValues.push(i);\n\t\tvar typeValues = Object.keys(cbVar.pieceTypes);\n\t\tthis.zobrist=new JocGame.Zobrist({\n\t\t\tboard: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: this.cbVar.geometry.boardSize,\n\t\t\t\tvalues: boardValues,\n\t\t\t},\n\t\t\twho: {\n\t\t\t\tvalues: [\"1\",\"-1\"],\t\t\t\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: this.cbPiecesCount,\n\t\t\t\tvalues: typeValues\n\t\t\t}\n\t\t});\t\n\t\t\n\t}\n\t\n\tModel.Game.cbGetPieceTypes = function() {\n\t\t//var $this=this;\n\t\n\t\tvar pTypes = [];\n\t\t\n\t\tvar nullGraph = {};\n\t\tfor(var pos=0;pos<this.cbVar.geometry.boardSize;pos++)\n\t\t\tnullGraph[pos]=[];\n\t\t\n\t\tfor(var typeIndex in this.cbVar.pieceTypes) {\n\t\t\tvar pType = this.cbVar.pieceTypes[typeIndex];\n\t\t\tpTypes[typeIndex] = {\n\t\t\t\tgraph: pType.graph || nullGraph,\n\t\t\t\tabbrev: pType.abbrev || '',\n\t\t\t\tvalue: pType.isKing?100:(pType.value || 1),\n\t\t\t\tisKing: !!pType.isKing,\n\t\t\t\tcastle: !!pType.castle,\n\t\t\t\tepTarget: !!pType.epTarget,\n\t\t\t\tepCatch: !!pType.epCatch,\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pTypes;\n\t}\n\n\tModel.Board.Init = function(aGame) {\n\t\tthis.zSign=0;\n\t}\n\n\tModel.Board.InitialPosition = function(aGame) {\n\t\tvar $this=this;\n\t\tif(USE_TYPED_ARRAYS)\n\t\t\tthis.board=new Int16Array(aGame.g.boardSize);\n\t\telse\n\t\t\tthis.board=[];\n\t\tfor(var pos=0;pos<aGame.g.boardSize;pos++)\n\t\t\tthis.board[pos]=-1;\n\t\tthis.kings={};\n\t\tthis.pieces=[];\n\t\tthis.ending={\n\t\t\t'1': false,\n\t\t\t'-1': false,\n\t\t}\n\t\tthis.lastMove=null;\n\t\tif(aGame.cbVar.castle)\n\t\t\tthis.castled={\n\t\t\t\t'1': false,\n\t\t\t\t'-1': false,\n\t\t\t}\n\t\tthis.zSign=aGame.zobrist.update(0,\"who\",-1);\n\n\t\tthis.noCaptCount = 0;\n\n\t\tif(aGame.mInitial) {\n\t\t\taGame.mInitial.pieces.forEach(function(piece) {\n\t\t\t\tvar piece1={}\n\t\t\t\tfor(var f in piece)\n\t\t\t\t\tif(piece.hasOwnProperty(f))\n\t\t\t\t\t\tpiece1[f]=piece[f];\n\t\t\t\t$this.pieces.push(piece1);\n\t\t\t});\n\t\t\tif(aGame.mInitial.lastMove)\n\t\t\t\tthis.lastMove={\n\t\t\t\t\tf: aGame.mInitial.lastMove.f,\n\t\t\t\t\tt: aGame.mInitial.lastMove.t,\n\t\t\t\t}\n\t\t\tif(aGame.mInitial.noCaptCount!==undefined)\n\t\t\t\tthis.noCaptCount=aGame.mInitial.noCaptCount;\n\t\t} else {\n\t\t\tfor(var typeIndex in aGame.cbVar.pieceTypes) {\n\t\t\t\tvar pType = aGame.cbVar.pieceTypes[typeIndex];\n\t\t\t\tvar initial = pType.initial || [];\n\t\t\t\tfor(var i=0;i<initial.length;i++) {\n\t\t\t\t\tvar desc = initial[i];\n\t\t\t\t\tvar piece = {\n\t\t\t\t\t\ts: desc.s,\n\t\t\t\t\t\tt: parseInt(typeIndex),\n\t\t\t\t\t\tp: desc.p,\n\t\t\t\t\t\tm: false,\n\t\t\t\t\t}\n\t\t\t\t\tthis.pieces.push(piece);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.pieces.sort(function(p1,p2) {\n\t\t\tif(p1.s!=p2.s)\n\t\t\t\treturn p2.s-p1.s;\n\t\t\tvar v1=aGame.cbVar.pieceTypes[p1.t].value || 100;\n\t\t\tvar v2=aGame.cbVar.pieceTypes[p2.t].value || 100;\n\t\t\tif(v1!=v2)\n\t\t\t\treturn v1-v2;\n\t\t\treturn p1.p-p2.p;\n\t\t});\n\n\t\tthis.pieces.forEach(function(piece,index) {\n\t\t\tpiece.i=index;\n\t\t\t$this.board[piece.p]=index;\n\t\t\tvar pType=aGame.g.pTypes[piece.t];\n\t\t\tif(pType.isKing)\n\t\t\t\t$this.kings[piece.s]=piece.p;\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",index,piece.p);\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"type\",piece.t,index);\n\t\t});\n\t\t\n\t\t//console.log(\"sign\",this.zSign);\n\t\t\n\t\tif(aGame.mInitial && aGame.mInitial.enPassant) {\n\t\t\tvar pos=cbVar.geometry.PosByName(aGame.mInitial.enPassant);\n\t\t\tif(pos>=0) {\n\t\t\t\tvar pos2;\n\t\t\t\t// TODO does not work for all geometries\n\t\t\t\tvar c=cbVar.geometry.C(pos);\n\t\t\t\tvar r=cbVar.geometry.R(pos);\n\t\t\t\tif(aGame.mInitial.turn==1)\n\t\t\t\t\tpos2=cbVar.geometry.POS(c,r-1);\n\t\t\t\telse\n\t\t\t\t\tpos2=cbVar.geometry.POS(c,r+1);\n\t\t\t\tthis.epTarget={\n\t\t\t\t\tp: pos,\n\t\t\t\t\ti: this.board[pos2],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tif(USE_TYPED_ARRAYS) {\n\t\t\tthis.board=new Int16Array(aBoard.board.length);\n\t\t\tthis.board.set(aBoard.board);\n\t\t} else {\n\t\t\tthis.board=[];\n\t\t\tvar board0=aBoard.board;\n\t\t\tvar boardLength=board0.length;\n\t\t\tfor(var i=0;i<boardLength;i++)\n\t\t\t\tthis.board.push(board0[i]);\n\t\t}\n\t\tthis.pieces=[];\n\t\tvar piecesLength=aBoard.pieces.length;\n\t\tfor(var i=0;i<piecesLength;i++) {\n\t\t\tvar piece=aBoard.pieces[i];\n\t\t\tthis.pieces.push({\n\t\t\t\ts: piece.s,\n\t\t\t\tp: piece.p,\n\t\t\t\tt: piece.t,\n\t\t\t\ti: piece.i,\n\t\t\t\tm: piece.m,\n\t\t\t});\n\t\t}\n\t\tthis.kings={\n\t\t\t'1': aBoard.kings[1],\n\t\t\t'-1': aBoard.kings[-1],\n\t\t}\n\t\tthis.check=aBoard.check;\n\t\tif(aBoard.lastMove)\n\t\t\tthis.lastMove={\n\t\t\t\tf: aBoard.lastMove.f,\n\t\t\t\tt: aBoard.lastMove.t,\n\t\t\t\tc: aBoard.lastMove.c,\n\t\t\t}\n\t\telse\n\t\t\tthis.lastMove=null;\n\t\tthis.ending={\n\t\t\t'1': aBoard.ending[1],\n\t\t\t'-1': aBoard.ending[-1],\n\t\t}\n\t\tif(aBoard.castled!==undefined) {\n\t\t\tthis.castled= {\n\t\t\t\t'1': aBoard.castled[1],\n\t\t\t\t'-1': aBoard.castled[-1],\n\t\t\t}\n\t\t}\n\t\tthis.noCaptCount=aBoard.noCaptCount;\n\t\tif(aBoard.epTarget)\n\t\t\tthis.epTarget={\n\t\t\t\tp: aBoard.epTarget.p,\n\t\t\t\ti: aBoard.epTarget.i,\n\t\t\t}\n\t\telse\n\t\t\tthis.epTarget=null;\n\t\tthis.mWho=aBoard.mWho;\n\t\tthis.zSign=aBoard.zSign;\n\t}\n\n\tModel.Board.cbApplyCastle = function(aGame,move,updateSign) {\n\t\tvar spec=aGame.cbVar.castle[move.f+\"/\"+move.cg];\n\t\tvar rookTo=spec.r[spec.r.length-1];\n\t\tvar rPiece=this.pieces[this.board[move.cg]];\n\t\tvar kingTo=spec.k[spec.k.length-1];\n\t\tvar kPiece=this.pieces[this.board[move.f]];\n\t\tif(updateSign) {\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",rPiece.i,move.cg);\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",rPiece.i,rookTo);\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",kPiece.i,move.f);\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",kPiece.i,kingTo);\n\t\t}\n\t\t\n\t\trPiece.p=rookTo;\n\t\trPiece.m=true;\n\t\tthis.board[move.cg]=-1;\n\t\t\n\t\tkPiece.p=kingTo;\n\t\tkPiece.m=true;\n\t\tthis.board[move.f]=-1;\n\t\t\n\t\tthis.board[rookTo]=rPiece.i;\n\t\tthis.board[kingTo]=kPiece.i;\n\t\tthis.castled[rPiece.s]=true;\n\t\t\n\t\tthis.kings[kPiece.s]=kingTo;\n\t\t\n\t\treturn [{\n\t\t\ti: rPiece.i,\n\t\t\tf: rookTo,\n\t\t\tt: -1,\n\t\t},{\n\t\t\ti: kPiece.i,\n\t\t\tf: kingTo,\n\t\t\tt: move.f,\n\t\t\tkp: move.f,\n\t\t\twho: kPiece.s,\n\t\t\tm: false,\n\t\t},{\n\t\t\ti: rPiece.i,\n\t\t\tf: -1,\n\t\t\tt: move.cg,\n\t\t\tm: false,\n\t\t\tcg: false,\n\t\t}];\n\t}\n\t\n\tModel.Board.cbQuickApply = function(aGame,move) {\n\t\tif(move.cg!==undefined)\n\t\t\treturn this.cbApplyCastle(aGame,move,false);\n\n\t\tvar undo=[];\n\t\tvar index=this.board[move.f];\n\t\tvar piece=this.pieces[index];\n\t\tif(move.c!=null) {\n\t\t\tundo.unshift({\n\t\t\t\ti: move.c,\n\t\t\t\tf: -1,\n\t\t\t\tt: this.pieces[move.c].p,\n\t\t\t});\n\t\t\tvar piece1=this.pieces[move.c];\n\t\t\tthis.board[piece1.p]=-1;\n\t\t\tpiece1.p=-1;\n\t\t}\n\t\tvar kp=this.kings[piece.s];\n\t\tif(aGame.g.pTypes[piece.t].isKing)\n\t\t\tthis.kings[piece.s]=move.t;\n\t\tundo.unshift({\n\t\t\ti: index,\n\t\t\tf: move.t,\n\t\t\tt: move.f,\n\t\t\tkp: kp,\n\t\t\twho: piece.s,\n\t\t\tty: piece.t,\n\t\t});\n\t\tpiece.p=move.t;\n\t\tif(move.pr!==undefined)\n\t\t\tpiece.t=move.pr;\n\t\tthis.board[move.f]=-1;\n\t\tthis.board[move.t]=index;\n\n\t\treturn undo;\n\t}\n\n\tModel.Board.cbQuickUnapply = function(aGame,undo) {\n\t\tfor(var i=0;i<undo.length;i++) {\n\t\t\tvar u=undo[i];\n\t\t\tvar piece=this.pieces[u.i];\n\t\t\tif(u.f>=0) {\n\t\t\t\tpiece.p=-1;\n\t\t\t\tthis.board[u.f]=-1;\n\t\t\t}\n\t\t\tif(u.t>=0) {\n\t\t\t\tpiece.p=u.t;\n\t\t\t\tthis.board[u.t]=u.i;\n\t\t\t}\n\t\t\tif(u.m!==undefined)\n\t\t\t\tpiece.m=u.m;\n\t\t\tif(u.kp!==undefined)\n\t\t\t\tthis.kings[u.who]=u.kp;\n\t\t\tif(u.ty!=undefined)\n\t\t\t\tpiece.t=u.ty;\n\t\t\tif(u.cg!=undefined)\n\t\t\t\tthis.castled[piece.s]=u.cg;\n\t\t}\n\t}\n\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\tvar piece=this.pieces[this.board[move.f]];\n\t\tif(move.cg!==undefined)\n\t\t\tthis.cbApplyCastle(aGame,move,true);\n\t\telse {\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.i,move.f);\n\t\t\tthis.board[piece.p]=-1;\n\t\t\tif(move.pr!==undefined) {\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"type\",piece.t,piece.i);\n\t\t\t\tpiece.t=move.pr;\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"type\",piece.t,piece.i);\n\t\t\t}\n\t\t\tif(move.c!=null) {\n\t\t\t\tvar piece1=this.pieces[move.c];\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece1.i,piece1.p);\n\t\t\t\tthis.board[piece1.p]=-1;\n\t\t\t\tpiece1.p=-1;\n\t\t\t\tpiece1.m=true;\n\t\t\t\tthis.noCaptCount=0;\n\t\t\t} else \n\t\t\t\tthis.noCaptCount++;\n\t\t\tpiece.p=move.t;\n\t\t\tpiece.m=true;\n\t\t\tthis.board[move.t]=piece.i;\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.i,move.t);\n\t\t\tif(aGame.g.pTypes[piece.t].isKing)\n\t\t\t\tthis.kings[piece.s]=move.t;\n\t\t}\n\t\tthis.check=!!move.ck;\n\t\tthis.lastMove={\n\t\t\tf: move.f,\n\t\t\tt: move.t,\n\t\t\tc: move.c,\n\t\t}\n\t\tif(move.ko!==undefined)\n\t\t\tthis.ending[piece.s]=move.ko;\n\t\tif(move.ept!==undefined)\n\t\t\tthis.epTarget={\n\t\t\t\tp: move.ept,\n\t\t\t\ti: piece.i,\n\t\t\t}\n\t\telse\n\t\t\tthis.epTarget=null;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"who\",-this.mWho);\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"who\",this.mWho);\t\n\t\t//this.cbIntegrity(aGame);\n\t}\n\n\tModel.Board.Evaluate = function(aGame) {\n\t\tvar debug=arguments[3]==\"debug\";\n\t\tvar $this=this;\n\t\tthis.mEvaluation=0;\n\t\tvar who=this.mWho;\n\t\tvar g=aGame.g;\n\t\tvar material;\n\t\tif(USE_TYPED_ARRAYS)\n\t\t\tmaterial={ \n\t\t\t\t'1': {\n\t\t\t\t\tcount: new Uint8Array(g.pTypes.length),\n\t\t\t\t\tbyType: {},\n\t\t\t\t},\n\t\t\t\t'-1': {\n\t\t\t\t\tcount: new Uint8Array(g.pTypes.length), \n\t\t\t\t\tbyType: {},\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tmaterial={ \n\t\t\t\t'1': {\n\t\t\t\t\tcount: [],\n\t\t\t\t\tbyType: {},\n\t\t\t\t},\n\t\t\t\t'-1': {\n\t\t\t\t\tcount: [], \n\t\t\t\t\tbyType: {},\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i=0;i<g.pTypes.length;i++)\n\t\t\t\tmaterial[\"1\"].count[i]=material[\"-1\"].count[i]=0;\n\t\t}\n\t\t\n\t\tif(aGame.mOptions.preventRepeat && aGame.GetRepeatOccurence(this)>2) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=aGame.cbOnPerpetual?who*aGame.cbOnPerpetual:JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar pieceValue={ '1': 0, '-1': 0 };\n\t\tvar distKingGraph={\n\t\t\t'1': g.distGraph[this.kings[-1]],\n\t\t\t'-1': g.distGraph[this.kings[1]],\n\t\t}\n\t\tvar distKing={ '1': 0, '-1': 0 };\n\t\tvar pieceCount={ '1': 0, '-1': 0 };\n\t\tvar posValue={ '1': 0, '-1': 0 };\n\t\t\n\t\tvar castlePiecesCount={ '1': 0, '-1': 0 };\n\t\tvar kingMoved={ '1': false, '-1': false };\n\t\t\n\t\tvar pieces=this.pieces;\n\t\tvar piecesLength=pieces.length;\n\t\tfor(var i=0;i<piecesLength;i++) {\n\t\t\tvar piece=pieces[i];\n\t\t\tif(piece.p>=0) {\n\t\t\t\tvar s=piece.s;\n\t\t\t\tvar pType=g.pTypes[piece.t];\n\t\t\t\tif(!pType.isKing)\n\t\t\t\t\tpieceValue[s]+=pType.value;\n\t\t\t\telse\n\t\t\t\t\tkingMoved[s]=piece.m;\n\t\t\t\tif(pType.castle && !piece.m)\n\t\t\t\t\tcastlePiecesCount[s]++;\n\t\t\t\tpieceCount[s]++;\n\t\t\t\tdistKing[s]+=distKingGraph[s][piece.p];\n\t\t\t\tposValue[s]+=cbVar.geometry.distEdge[piece.p];\n\t\t\t\tvar mat=material[s];\n\t\t\t\tmat.count[piece.t]++;\n\t\t\t\tvar byType=mat.byType;\n\t\t\t\tif(byType[piece.t]===undefined)\n\t\t\t\t\tbyType[piece.t]=[piece];\n\t\t\t\telse\n\t\t\t\t\tbyType[piece.t].push(piece);\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(this.lastMove && this.lastMove.c!=null) {\n\t\t\tvar piece=this.pieces[this.board[this.lastMove.t]];\n\t\t\tpieceValue[-piece.s]+=this.cbStaticExchangeEval(aGame,piece.p,piece.s,{piece:piece})\n\t\t}\n\t\tvar kingFreedom={ '1': 0, '-1': 0 };\n\t\tvar endingDistKing={ '1': 0, '-1': 0 };\n\t\tvar distKingCorner={ '1': 0, '-1': 0 };\n\t\tfunction DistKingCorner(side) {\n\t\t\tvar dist=Infinity;\n\t\t\tfor(var corner in cbVar.geometry.corners) \n\t\t\t\tdist=Math.min(dist,g.distGraph[$this.kings[side]][corner]);\n\t\t\treturn dist-Math.sqrt(g.boardSize);\n\t\t}\n\t\tif(this.ending[1]) {\n\t\t\t//kingFreedom[1]=this.cbEvaluateKingFreedom(aGame,1)-g.boardSize;\n\t\t\t//endingDistKing[1]=g.distGraph[this.kings[-1]][this.kings[1]]-Math.sqrt(g.boardSize);\n\t\t\tendingDistKing[1]=(distKing['1']-Math.sqrt(g.boardSize))/pieceCount['1'];\n\t\t\tif(cbVar.geometry.corners)\n\t\t\t\tdistKingCorner[1]=DistKingCorner(1);\n\t\t}\n\t\tif(this.ending[-1]) {\n\t\t\t//kingFreedom[-1]=this.cbEvaluateKingFreedom(aGame,-1)-g.boardSize;\n\t\t\t//endingDistKing[-1]=g.distGraph[this.kings[-1]][this.kings[1]]-Math.sqrt(g.boardSize);\n\t\t\tendingDistKing[-1]=(distKing['-1']-Math.sqrt(g.boardSize))/pieceCount['-1'];\n\t\t\tif(cbVar.geometry.corners)\n\t\t\t\tdistKingCorner[1]=DistKingCorner(-1);\n\t\t}\n\t\t\n\t\tvar evalValues={\n\t\t\t\"pieceValue\": pieceValue['1']-pieceValue[-1],\n\t\t\t\"pieceValueRatio\": (pieceValue['1']-pieceValue[-1])/(pieceValue['1']+pieceValue['-1']+1),\n\t\t\t\"posValue\": posValue['1']-posValue[-1],\n\t\t\t\"averageDistKing\": distKing['1']/pieceCount['1']-distKing['-1']/pieceCount[-1],\n\t\t\t\"check\": this.check?-who:0,\n\t\t\t\"endingKingFreedom\": kingFreedom[1]-kingFreedom[-1],\n\t\t\t\"endingDistKing\": endingDistKing['1']-endingDistKing['-1'],\n\t\t\t\"distKingCorner\": distKingCorner['1']-distKingCorner['-1'],\n\t\t}\n\t\tif(cbVar.castle)\n\t\t\tevalValues[\"castle\"] = \n\t\t\t\t(this.castled[1] ? 1 : (kingMoved[1]? 0 : castlePiecesCount[1] / (g.castleablePiecesCount[1]+1))) -  \n\t\t\t\t(this.castled[-1] ? 1 : (kingMoved[-1]? 0 : castlePiecesCount[-1] / (g.castleablePiecesCount[-1]+1)));\n\t\t\n\t\tif(cbVar.evaluate)\n\t\t\tcbVar.evaluate.call(this,aGame,evalValues,material);\n\n\t\tvar evParams=aGame.mOptions.levelOptions;\n\t\tfor(var name in evalValues) {\n\t\t\tvar value=evalValues[name];\n\t\t\tvar factor=evParams[name+'Factor'] || 0;\n\t\t\tvar weighted=value*factor;\n\t\t\tif(debug)\n\t\t\t\tconsole.log(name,\"=\",value,\"*\",factor,\"=>\",weighted);\n\t\t\tthis.mEvaluation+=weighted;\n\t\t}\n\t\tif(debug)\n\t\t\tconsole.log(\"Evaluation\",this.mEvaluation);\n\t}\n\t\n\tModel.Board.cbGeneratePseudoLegalMoves = function(aGame) {\n\t\tvar $this=this;\n\t\tvar moves=[];\n\t\tvar cbVar=aGame.cbVar;\n\t\tvar who=this.mWho;\n\t\tvar castlePieces=cbVar.castle && !this.check && !this.castled[who]?[]:null; // consider castle ?\n\t\tvar king=-1;\n\t\t\n\t\tfunction PromotedMoves(piece,move) {\n\t\t\tvar promoFnt=aGame.cbVar.promote;\n\t\t\tif(!promoFnt) {\n\t\t\t\tmoves.push(move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar promo=promoFnt.call($this,aGame,piece,move);\n\t\t\tif(promo==null)\n\t\t\t\treturn;\n\t\t\tif(promo.length==0)\n\t\t\t\tmoves.push(move);\n\t\t\telse if(promo.length==1) {\n\t\t\t\tmove.pr=promo[0];\n\t\t\t\tmoves.push(move);\n\t\t\t} else {\n\t\t\t\tfor(var i=0;i<promo.length;i++) {\n\t\t\t\t\tvar pr=promo[i];\n\t\t\t\t\tmoves.push({\n\t\t\t\t\t\tf: move.f,\n\t\t\t\t\t\tt: move.t,\n\t\t\t\t\t\tc: move.c,\n\t\t\t\t\t\tpr: pr,\n\t\t\t\t\t\tept: move.ept,\n\t\t\t\t\t\tep: move.ep,\n\t\t\t\t\t\ta: move.a,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar piecesLength=this.pieces.length;\n\t\tfor(var i=0;i<piecesLength;i++) {\n\t\t\tvar piece=this.pieces[i];\n\t\t\tif(piece.p<0 || piece.s!=who)\n\t\t\t\tcontinue;\n\t\t\tvar pType=aGame.g.pTypes[piece.t];\n\t\t\t\n\t\t\tif(pType.isKing) {\n\t\t\t\tif(piece.m) // king moved, no castling\n\t\t\t\t\tcastlePieces=null;\n\t\t\t\telse\n\t\t\t\t\tking=piece;\n\t\t\t}\n\t\t\tif(castlePieces && pType.castle && !piece.m) // rook considered for castle\n\t\t\t\tcastlePieces.push(piece);\n\t\t\t\n\t\t\tvar graph, graphLength;\n\t\t\tgraph=pType.graph[piece.p];\n\t\t\tgraphLength=graph.length;\n\t\t\tfor(var j=0;j<graphLength;j++) {\n\t\t\t\tvar line=graph[j];\n\t\t\t\tvar screen=false;\n\t\t\t\tvar lineLength=line.length;\n\t\t\t\tvar lastPos=null;\n\t\t\t\tfor(var k=0;k<lineLength;k++) {\n\t\t\t\t\tvar tg1=line[k];\n\t\t\t\t\tvar pos1=tg1 & MASK;\n\t\t\t\t\tvar index1=this.board[pos1];\n\t\t\t\t\tif(index1<0 && (!pType.epCatch || !this.epTarget || this.epTarget.p!=pos1)) {\n\t\t\t\t\t\tif((tg1 & FLAG_MOVE) && screen==false)\n\t\t\t\t\t\t\tPromotedMoves(piece,{\n\t\t\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\t\t\tt: pos1,\n\t\t\t\t\t\t\t\tc: null,\n\t\t\t\t\t\t\t\ta: pType.abbrev,\n\t\t\t\t\t\t\t\tept: lastPos==null || !pType.epTarget?undefined:lastPos,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t} else if(tg1 & FLAG_SCREEN_CAPTURE) {\n\t\t\t\t\t\tif(screen) {\n\t\t\t\t\t\t\tvar piece1=this.pieces[index1];\n\t\t\t\t\t\t\tif(piece1.s!=piece.s)\n\t\t\t\t\t\t\t\tPromotedMoves(piece,{\n\t\t\t\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\t\t\t\tt: pos1,\n\t\t\t\t\t\t\t\t\tc: piece1.i,\n\t\t\t\t\t\t\t\t\ta: pType.abbrev,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tscreen=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar piece1;\n\t\t\t\t\t\tif(index1<0)\n\t\t\t\t\t\t\tpiece1=this.pieces[this.epTarget.i];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpiece1=this.pieces[index1];\n\t\t\t\t\t\tif(piece1.s!=piece.s && (tg1 & FLAG_CAPTURE) && (!(tg1 & FLAG_CAPTURE_KING) || aGame.g.pTypes[piece1.t].isKing) &&\n\t\t\t\t\t\t\t\t(!(tg1 & FLAG_CAPTURE_NO_KING) || !aGame.g.pTypes[piece1.t].isKing))\n\t\t\t\t\t\t\tPromotedMoves(piece,{\n\t\t\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\t\t\tt: pos1,\n\t\t\t\t\t\t\t\tc: piece1.i,\n\t\t\t\t\t\t\t\ta: pType.abbrev,\n\t\t\t\t\t\t\t\tep: index1<0,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlastPos=pos1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(castlePieces) {\n\t\t\tfor(var i=0;i<castlePieces.length;i++) {\n\t\t\t\tvar rook=castlePieces[i];\n\t\t\t\tvar spec=aGame.cbVar.castle[king.p+\"/\"+rook.p];\n\t\t\t\tif(!spec)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar rookOk=true;\n\t\t\t\tfor(var j=0;j<spec.r.length;j++) {\n\t\t\t\t\tvar pos=spec.r[j];\n\t\t\t\t\tif(this.board[pos]>=0 && pos!=king.p && pos!=rook.p) {\n\t\t\t\t\t\trookOk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rookOk) {\n\t\t\t\t\tvar kingOk=true;\n\t\t\t\t\tfor(var j=0;j<spec.k.length;j++) {\n\t\t\t\t\t\tvar pos=spec.k[j];\n\t\t\t\t\t\tif((this.board[pos]>=0 && pos!=rook.p && pos!=king.p) || this.cbGetAttackers(aGame,pos,who).length>0) {\n\t\t\t\t\t\t\tkingOk=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(kingOk) {\n\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\tf: king.p,\n\t\t\t\t\t\t\tt: spec.k[spec.k.length-1],\n\t\t\t\t\t\t\tc: null,\n\t\t\t\t\t\t\tcg: rook.p,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn moves;\n\t}\n\t\n\t// Static Exchange Evaluation, as per http://chessprogramming.wikispaces.com/Static+Exchange+Evaluation\n\tModel.Board.cbStaticExchangeEval = function(aGame,pos,side,lastCaptured) {\n\t\tvar value=0;\n\t\tvar piece1=this.cbGetSmallestAttacker(aGame,pos,side);\n\t\tif(piece1) {\n\t\t\tvar who=this.mWho;\n\t\t\tthis.mWho=piece1.s;\n\t\t\tvar undo=this.cbQuickApply(aGame,{\n\t\t\t\tf: piece1.p,\n\t\t\t\tt: pos,\n\t\t\t\tc: lastCaptured.piece.i,\n\t\t\t});\n\t\t\tvar lastCapturedValue=aGame.g.pTypes[lastCaptured.piece.t].value;\n\t\t\tlastCaptured.piece=piece1;\n\t\t\tvalue=Math.max(0,lastCapturedValue-this.cbStaticExchangeEval(aGame,pos,-side,lastCaptured));\n\t\t\tthis.cbQuickUnapply(aGame,undo);\n\t\t\t//this.cbIntegrity(aGame);\n\t\t\tthis.mWho=who;\n\t\t}\n\t\treturn value;\t\t\n\t}\n\t\n\tModel.Board.cbGetSmallestAttacker = function(aGame,pos,side) {\n\t\tvar attackers=this.cbGetAttackers(aGame,pos,side);\n\t\tif(attackers.length==0)\n\t\t\treturn null;\n\t\tvar smallestValue=Infinity;\n\t\tvar smallestAttacker=null;\n\t\tvar attackersLength=attackers.length;\n\t\tfor(var i=0;i<attackersLength;i++) {\n\t\t\tvar attacker=attackers[i];\n\t\t\tvar attackerValue=aGame.g.pTypes[attacker.t].value;\n\t\t\tif(attackerValue<smallestValue) {\n\t\t\t\tsmallestValue=attackerValue;\n\t\t\t\tsmallestAttacker=attacker;\n\t\t\t} \n\t\t}\n\t\treturn smallestAttacker;\n\t}\n\n\tModel.Board.cbCollectAttackers=function(who,graph,attackers,isKing) {\n\t\tfor(var pos1 in graph) {\n\t\t\tvar branch=graph[pos1];\n\t\t\tvar index1=this.board[pos1];\n\t\t\tif(index1<0)\n\t\t\t\tthis.cbCollectAttackers(who,branch.e,attackers,isKing);\n\t\t\telse {\n\t\t\t\tvar piece1=this.pieces[index1];\n\t\t\t\tif(piece1.s==-who && (\n\t\t\t\t\t\t(branch.t && (piece1.t in branch.t)) ||\n\t\t\t\t\t\t(isKing && branch.tk && (piece1.t in branch.tk))))\n\t\t\t\t\tattackers.push(piece1);\n\t\t\t}\n\t\t}\n\t}\n\n\tModel.Board.cbCollectAttackersScreen=function(who,graph,attackers,isKing,screen) {\n\t\tfor(var pos1 in graph) {\n\t\t\tvar branch=graph[pos1];\n\t\t\tvar index1=this.board[pos1];\n\t\t\tif(index1<0)\n\t\t\t\tthis.cbCollectAttackersScreen(who,branch.e,attackers,isKing,screen);\n\t\t\telse {\n\t\t\t\tvar piece1=this.pieces[index1];\n\t\t\t\tif(!screen && piece1.s==-who && (\n\t\t\t\t\t\t(branch.t && (piece1.t in branch.t)) ||\n\t\t\t\t\t\t(isKing && branch.tk && (piece1.t in branch.tk))))\n\t\t\t\t\tattackers.push(piece1);\n\t\t\t\telse if(!screen)\n\t\t\t\t\tthis.cbCollectAttackersScreen(who,branch.e,attackers,isKing,true);\n\t\t\t\telse if(screen && piece1.s==-who && branch.ts && (piece1.t in branch.ts))\n\t\t\t\t\tattackers.push(piece1);\n\t\t\t}\n\t\t}\n\t}\n\n\tModel.Board.cbGetAttackers = function(aGame,pos,who,isKing) {\n\t\tvar attackers=[];\n\t\tif(aGame.cbUseScreenCapture)\n\t\t\tthis.cbCollectAttackersScreen(who,aGame.g.threatGraph[who][pos],attackers,isKing,false);\n\t\telse\n\t\t\tthis.cbCollectAttackers(who,aGame.g.threatGraph[who][pos],attackers,isKing);\n\t\treturn attackers;\n\t}\n\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\tvar moves=this.cbGeneratePseudoLegalMoves(aGame);\n\t\tthis.mMoves = [];\n\t\tvar kingOnly=true;\n\t\tvar selfKingPos=this.kings[this.mWho];\n\t\tvar movesLength=moves.length;\n\t\tfor(var i=0;i<movesLength;i++) {\n\t\t\tvar move=moves[i];\n\t\t\tvar undo=this.cbQuickApply(aGame,move);\n\t\t\tvar inCheck=this.cbGetAttackers(aGame,this.kings[this.mWho],this.mWho,true).length>0;\n\t\t\tif(!inCheck) {\n\t\t\t\tvar oppInCheck=this.cbGetAttackers(aGame,this.kings[-this.mWho],-this.mWho,true).length>0;\n\t\t\t\tmove.ck = oppInCheck; \n\t\t\t\tthis.mMoves.push(move);\n\t\t\t\tif(move.f!=selfKingPos)\n\t\t\t\t\tkingOnly=false;\n\t\t\t}\n\t\t\tthis.cbQuickUnapply(aGame,undo);\n\t\t}\n\t\tif(this.mMoves.length==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=aGame.cbOnStaleMate?aGame.cbOnStaleMate*this.mWho:JocGame.DRAW;\n\t\t\tif(this.check)\n\t\t\t\tthis.mWinner=-this.mWho;\n\t\t} else if(this.ending[this.mWho]) {\n\t\t\tif(!kingOnly) {\n\t\t\t\tfor(var i=0;i<this.mMoves.length;i++)\n\t\t\t\t\tthis.mMoves[i].ko=false;\n\t\t\t}\n\t\t} else if(!this.ending[this.mWho]) {\n\t\t\tif(kingOnly && !this.check) {\n\t\t\t\tfor(var i=0;i<this.mMoves.length;i++)\n\t\t\t\t\tthis.mMoves[i].ko=true;\n\t\t\t}\n\t\t}\n\t}\n\n\tModel.Board.GetSignature = function() {\n\t\treturn this.zSign;\n\t}\n\n\tModel.Move.Init = function(args) {\n\t\tfor(var f in args)\n\t\t\tif(args.hasOwnProperty(f))\n\t\t\t\tthis[f]=args[f];\n\t}\n\n\tModel.Move.Equals = function(move) {\n\t\treturn this.f==move.f && this.t==move.t && this.pr==move.pr;\n\t}\n\t\n\tModel.Move.CopyFrom=function(move) {\n\t\tthis.Init(move);\n\t}\n\n\tModel.Move.ToString = function() {\n\t\tif(this.compact)\n\t\t\treturn this.compact;\n\t\tvar str;\n\t\tif(this.cg!==undefined) {\n\t\t\tstr=cbVar.castle[this.f+\"/\"+this.cg].n;\n\t\t} else {\n\t\t\tstr=this.a || '';\n\t\t\tstr+=cbVar.geometry.PosName(this.f);\n\t\t\tif(this.c==null)\n\t\t\t\tstr+=\"-\";\n\t\t\telse\n\t\t\t\tstr+=\"x\";\n\t\t\tstr+=cbVar.geometry.PosName(this.t);\n\t\t}\n\t\t/*\n\t\tif(this.ep)\n\t\t\tstr+=\"e.p.\";\n\t\t*/\n\t\tif(this.pr!==undefined) {\n\t\t\tvar pType=cbVar.pieceTypes[this.pr];\n\t\t\tif(pType && pType.abbrev && pType.abbrev.length>0 && !pType.silentPromo)\n\t\t\t\tstr+=\"=\"+pType.abbrev;\n\t\t}\n\t\tif(this.ck)\n\t\t\tstr+=\"+\";\n\t\treturn str;\n\t}\n\t\n\t/* compact the move notation while preventing ambiguities */\n\tModel.Board.CompactMoveString = function(aGame,aMove,allMoves) {\n\t\tif(typeof aMove.ToString!=\"function\") // ensure proper move object, if necessary\n\t\t\taMove=aGame.CreateMove(aMove);\n\t\tvar moveStr=aMove.ToString();\n\t\tvar m=/^([A-Z]?)([a-z])([1-9][0-9]*)([-x])([a-z])([1-9][0-9]*)(.*?)$/.exec(moveStr);\n\t\tif(!m)\n\t\t\treturn moveStr;\n\t\tvar moveSuffix=m[7];\n\n\t\tif(!allMoves)\n\t\t\tallMoves={};\n\t\tif(!allMoves.value)\n\t\t\tallMoves.value=[];\n\t\tif(allMoves.value.length==0) {\n\t\t\tvar oldMoves=this.mMoves;\n\t\t\tif(!this.mMoves || this.mMoves.length==0)\n\t\t\t\tthis.GenerateMoves(aGame);\n\t\t\tfor(var i=0;i<this.mMoves.length;i++) {\n\t\t\t\tvar move=this.mMoves[i];\n\t\t\t\tif(typeof move.ToString!=\"function\") // ensure proper move object, if necessary\n\t\t\t\t\tmove=aGame.CreateMove(move);\n\t\t\t\tallMoves.value.push({\n\t\t\t\t\tstr: move.ToString(),\n\t\t\t\t\tmove: move,\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.mMoves=oldMoves;\n\t\t}\n\t\tvar matching=[];\n\t\tallMoves.value.forEach(function(mv) {\n\t\t\tvar m2=/^([A-Z]?[a-z][1-9][0-9]*[-x][a-z][1-9][0-9]*)(.*?)$/.exec(mv.str);\n\t\t\tif(m2) {\n\t\t\t\tif(mv.move.t==aMove.t && (mv.move.a || '')==m[1] && m2[2]==moveSuffix) {\n\t\t\t\t\tmatching.push(mv.move);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t});\n\n\t\tif(matching.length==1) {\n\t\t\tif(m[1]=='' && m[4]=='x')\n\t\t\t\treturn m[2]+'x'+m[5]+m[6]+m[7];\n\t\t\telse\n\t\t\t\treturn m[1]+(m[4]=='x'?'x':'')+m[5]+m[6]+m[7];\n\t\t}\n\t\tif(cbVar.geometry.CompactCrit) {\n\t\t\tvar crit=\"\";\n\t\t\tfor(var i=0;;i++) {\n\t\t\t\tvar from2=cbVar.geometry.CompactCrit(aMove.f,i);\n\t\t\t\tif(from2==null)\n\t\t\t\t\treturn moveStr;\n\t\t\t\tcrit+=from2;\n\t\t\t\tvar matching2=[];\n\t\t\t\tfor(var j=0;j<matching.length;j++) {\n\t\t\t\t\tvar move2=matching[j];\n\t\t\t\t\tif(cbVar.geometry.CompactCrit(move2.f,i)==from2)\n\t\t\t\t\t\tmatching2.push(move2);\n\t\t\t\t}\n\n\t\t\t\tconsole.assert(matching2.length>0);\n\t\t\t\tif(matching2.length==1)\n\t\t\t\t\treturn m[1]+crit+(m[4]=='x'?'x':'')+m[5]+m[6]+m[7];\n\t\t\t\tmatching=matching2;\n\t\t\t}\n\t\t}\n\t\treturn moveStr;\n\t}\n\t\n\tModel.Board.cbIntegrity = function(aGame) {\n\t\tvar $this=this;\n\t\tfunction Assert(cond,text) {\n\t\t\tif(!cond) {\n\t\t\t\tconsole.error(text);\n\t\t\t\tdebugger;\n\t\t\t}\n\t\t}\n\t\tfor(var pos=0;pos<this.board.length;pos++) {\n\t\t\tvar index=this.board[pos];\n\t\t\tif(index>=0) {\n\t\t\t\tvar piece=$this.pieces[index];\n\t\t\t\tAssert(piece!==undefined,\"no piece at pos\");\n\t\t\t\tAssert(piece.p==pos,\"piece has different pos\");\n\t\t\t}\n\t\t}\n\t\tfor(var index=0;index<this.pieces.length;index++) {\n\t\t\tvar piece=this.pieces[index];\n\t\t\tif(piece.p>=0) {\n\t\t\t\tAssert($this.board[piece.p]==index,\"board index mismatch\");\n\t\t\t}\n\t\t}\n\t}\n\n\tModel.Game.Import = function(format,data) {\n\t\tvar turn, pieces=[], castle={'1':{},'-1':{}}, enPassant=null, noCaptCount=0;\n\n\t\tif(format=='pjn') {\n\t\t\tvar result={\n\t\t\t\tstatus: false,\n\t\t\t\terror: 'parse',\n\t\t\t}\n\t\t\tvar fenParts=data.split(' ');\n\t\t\tif(fenParts.length!=6) {\n\t\t\t\tconsole.warn(\"FEN should have 6 parts\");\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tvar fenRows=fenParts[0].split('/');\n\t\t\tvar fenHeight = cbVar.geometry.fenHeight || cbVar.geometry.height;\n\t\t\tif(fenRows.length!=fenHeight) {\n\t\t\t\tconsole.warn(\"FEN board should have\",fenHeight,\"rows, got\",fenRows.length);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tvar piecesMap={}\n\t\t\t\n\t\t\tfor(var index in cbVar.pieceTypes) {\n\t\t\t\tvar pType=cbVar.pieceTypes[index];\n\t\t\t\tvar abbrev=pType.fenAbbrev || pType.abbrev || 'X';\n\t\t\t\tpiecesMap[abbrev.toUpperCase()]={\n\t\t\t\t\ts: 1,\n\t\t\t\t\tt: index,\n\t\t\t\t}\n\t\t\t\tpiecesMap[abbrev.toLowerCase()]={\n\t\t\t\t\ts: -1,\n\t\t\t\t\tt: index,\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar FenRowPos = cbVar.geometry.FenRowPos || function(rowIndex,colIndex) {\n\t\t\t\treturn (cbVar.geometry.height-1-rowIndex)*cbVar.geometry.width+colIndex;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO row/col does not fit all geometries\n\t\t\tfenRows.forEach(function(row,rowIndex) {\n\t\t\t\tvar colIndex=0;\n\t\t\t\tfor(var i=0;i<row.length;i++) {\n\t\t\t\t\tvar ch=row.substr(i,1);\n\t\t\t\t\tvar pieceDescr=piecesMap[ch];\n\t\t\t\t\tif(pieceDescr!==undefined) {\n\t\t\t\t\t\tvar pos=FenRowPos(rowIndex,colIndex);\n\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\tvar piece={\n\t\t\t\t\t\t\ts: pieceDescr.s,\n\t\t\t\t\t\t\tt: pieceDescr.t,\n\t\t\t\t\t\t\tp: pos,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar moved=true;\n\t\t\t\t\t\tvar initial1=cbVar.pieceTypes[piece.t].initial || [];\n\t\t\t\t\t\tfor(var j=0;j<initial1.length;j++) {\n\t\t\t\t\t\t\tvar desc=initial1[j];\n\t\t\t\t\t\t\tif(desc.s==piece.s && desc.p==pos)\n\t\t\t\t\t\t\t\tmoved=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpiece.m=moved;\n\t\t\t\t\t\tpieces.push(piece);\n\t\t\t\t\t} else if(!isNaN(parseInt(ch))) \n\t\t\t\t\t\tcolIndex+=parseInt(ch);\n\t\t\t\t\telse {\n\t\t\t\t\t\tconsole.warn(\"FEN invalid board spec\",ch);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tpieces.sort(function(p1,p2) {\n\t\t\t\treturn p2.s-p1.s;\n\t\t\t});\n\t\t\tif(fenParts[1]=='w')\n\t\t\t\tturn=1;\n\t\t\telse if(fenParts[1]=='b')\n\t\t\t\tturn=-1;\n\t\t\telse {\n\t\t\t\tconsole.warn(\"FEN invalid turn spec\",fenParts[1]);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcastle[1].k=fenParts[2].indexOf('K')>=0;\n\t\t\tcastle[1].q=fenParts[2].indexOf('Q')>=0;\n\t\t\tcastle[-1].k=fenParts[2].indexOf('k')>=0;\n\t\t\tcastle[-1].q=fenParts[2].indexOf('q')>=0;\n\t\t\tenPassant=fenParts[3]=='-'?null:fenParts[3];\n\t\t\tvar noCaptCount1=parseInt(fenParts[4]);\n\t\t\tif(!isNaN(noCaptCount1))\n\t\t\t\tnoCaptCount=noCaptCount1;\n\t\t\t\n\t\t\tvar initial={\n\t\t\t\tpieces: pieces,\n\t\t\t\tturn: turn,\n\t\t\t\tcastle: castle,\n\t\t\t\tenPassant: enPassant,\n\t\t\t\tnoCaptCount: noCaptCount,\n\t\t\t}\n\t\t\tvar status=true;\n\t\t\tif(cbVar.importGame)\n\t\t\t\tcbVar.importGame.call(this,initial,format,data);\n\t\t\t\n\t\t\treturn {\n\t\t\t\tstatus: status,\n\t\t\t\tinitial: initial,\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tstatus: false,\n\t\t\terror: 'unsupported',\n\t\t}\n\t}\n\n\t\n})();"],"file":"baby-chess-model.js"}