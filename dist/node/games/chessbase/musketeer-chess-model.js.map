{"version":3,"names":[],"mappings":"","sources":["musketeer-model.js"],"sourcesContent":["(function() {\n\t\n\t// in case opponents don't agree\n\tvar DEFAULT_TYPE1 = 9;\n\tvar DEFAULT_TYPE2 = 11;\n\t\n\t// musketeer geometry, adding rows \"0\" and \"9\"\n\tvar geometry = Model.Game.cbBoardGeometryGrid(8,10);\n\n    // substract one row because of row \"0\"\n    geometry.PosName = function(pos){ \n        return String.fromCharCode((\"a\".charCodeAt(0))+this.C(pos)) + (this.R(pos)) ;\n    }\n\t\n\tvar confine = {};\n\t// excluding rows \"0\" and \"9\" from game play\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\tif(!(\n\t\t\t\t(pos==0)||(pos==1)||(pos==2)||(pos==3)||(pos==4)||(pos==5)||(pos==6)||(pos==7)||(pos==72)||(pos==73)||(pos==74)||(pos==75)||(pos==76)||(pos==77)||(pos==78)||(pos==79) \n\t\t\t))\n\t\t\tconfine[pos]=1;\n\t}\n\t\n\tModel.Game.cbDefine = function() {\n\t\t\n\t\tvar classicPieces = { \n\t\t\t0: {\n\t\t\t\tname: 'pawn-w',\n\t\t\t\taspect: 'fr-pawn',\n\t\t\t\tgraph: this.cbPawnGraph(geometry,1,confine),\n\t\t\t\tvalue: 1,\n\t\t\t\tabbrev: '',\n\t\t\t\tfenAbbrev: 'P',\n\t\t\t\tepCatch: true,\n\t\t\t\t//initial:[{s:1,p:57}] // debug stuff fro promo testing\n\t\t\t},\n\t\t\t\n\t\t\t1: {\n\t\t\t\tname: 'ipawn-w',\n\t\t\t\taspect: 'fr-pawn',\n\t\t\t\tgraph: this.cbInitialPawnGraph(geometry,1,confine),\n\t\t\t\tvalue: 1,\n\t\t\t\tabbrev: '',\n\t\t\t\tfenAbbrev: 'P',\n\t\t\t\tinitial: [{s:1,p:16},{s:1,p:17},{s:1,p:18},{s:1,p:19},{s:1,p:20},{s:1,p:21},{s:1,p:22},{s:1,p:23}],\n\t\t\t\tepTarget: true,\n\t\t\t},\n\t\t\t\n\t\t\t2: {\n\t\t\t\tname: 'pawn-b',\n\t\t\t\taspect: 'fr-pawn',\n\t\t\t\tgraph: this.cbPawnGraph(geometry,-1,confine),\n\t\t\t\tvalue: 1,\n\t\t\t\tabbrev: '',\n\t\t\t\tfenAbbrev: 'P',\n\t\t\t\tepCatch: true,\n\t\t\t\t// initial:[{s:-1,p:17}] // debug stuff fro promo testing\t\t\t\t\n\t\t\t},\n\t\n\t\t\t3: {\n\t\t\t\tname: 'ipawn-b',\n\t\t\t\taspect: 'fr-pawn',\n\t\t\t\tgraph: this.cbInitialPawnGraph(geometry,-1,confine),\n\t\t\t\tvalue: 1,\n\t\t\t\tabbrev: '',\n\t\t\t\tfenAbbrev: 'P',\n\t\t\t\tinitial: [{s:-1,p:56},{s:-1,p:57},{s:-1,p:58},{s:-1,p:59},{s:-1,p:60},{s:-1,p:61},{s:-1,p:62},{s:-1,p:63}],\n\t\t\t\tepTarget: true,\n\t\t\t},\n\t\t\t\n\t\t\t4: {\n\t\t\t\tname: 'knight',\n\t\t\t\taspect: 'fr-knight',\n\t\t\t\tgraph: this.cbKnightGraph(geometry,confine),\n\t\t\t\tvalue: 2.9,\n\t\t\t\tabbrev: 'N',\n\t\t\t\tinitial: [{s:1,p:9},{s:1,p:14},{s:-1,p:65},{s:-1,p:70}],\n\t\t\t},\n\t\t\t\n\t\t\t5: {\n\t\t\t\tname: 'bishop',\n\t\t\t\taspect: 'fr-bishop',\n\t\t\t\tgraph: this.cbBishopGraph(geometry,confine),\n\t\t\t\tvalue: 3.05,\n\t\t\t\tabbrev: 'B',\n\t\t\t\tinitial: [{s:1,p:10},{s:1,p:13},{s:-1,p:66},{s:-1,p:69}],\n\t\t\t},\n\t\n\t\t\t6: {\n\t\t\t\tname: 'rook',\n\t\t\t\taspect: 'fr-rook',\n\t\t\t\tgraph: this.cbRookGraph(geometry,confine),\n\t\t\t\tvalue: 4.95,\n\t\t\t\tabbrev: 'R',\n\t\t\t\tinitial: [{s:1,p:8},{s:1,p:15},{s:-1,p:64},{s:-1,p:71}],\n\t\t\t\tcastle: true,\n\t\t\t},\n\t\n\t\t\t7: {\n\t\t\t\tname: 'queen',\n\t\t\t\taspect: 'fr-queen',\n\t\t\t\tgraph: this.cbQueenGraph(geometry,confine),\n\t\t\t\tvalue: 9.15,\n\t\t\t\tabbrev: 'Q',\n\t\t\t\tinitial: [{s:1,p:11},{s:-1,p:67}],\n\t\t\t},\n\t\t\t\n\t\t\t8: {\n\t\t\t\tname: 'king',\n\t\t\t\taspect: 'fr-king',\n\t\t\t\tisKing: true,\n\t\t\t\tgraph: this.cbKingGraph(geometry,confine),\n\t\t\t\tabbrev: 'K',\n\t\t\t\tinitial: [{s:1,p:12},{s:-1,p:68}],\n\t\t\t}\n\t\t};\n\n\t\t// musketeer xtra pieces\n\t\tvar piecesTypes = Object.assign({},classicPieces,{\n\t\t\t\n\t\t\t\t\t\t\t11: {\n\t\t\t\t\tname: 'leopard',\n\t\t\t\t\taspect: 'fr-leopard',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n\t            \t\t\t\tthis.cbXQElephantGraph(geometry,confine),\n\t            \t\t\t\tthis.cbShortRangeGraph(geometry,\n\t            \t\t\t\t\t[\n\t            \t\t\t\t\t [-1,-1],[-1,1],[1,-1],[1,1],\n\t            \t\t\t\t\t [-2,-1],[-1,-2],[-2,1],[-1,2],\n\t            \t\t\t\t\t [1,2],[2,1],[2,-1],[1,-2]\n\t            \t\t\t\t\t],confine)\n\t            \t\t\t),\n\t\t\t\t\tvalue: 4.5,\n\t\t\t\t\tabbrev: 'Le',\n\t\t\t\t\tinitial: [{s:1,p:24},{s:-1,p:43}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t14: {\n\t\t\t\t\tname: 'fortress',\n\t\t\t\t\taspect: 'fr-fortress',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n            \t\t\t\tthis.cbShortRangeGraph(geometry,[[-1,-2],[0,-2],[1,-2],[-1,2],[0,2],[1,2],[-2,0],[2,0]],confine),\n            \t\t\t\tthis.cbLongRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]],confine,null,3)\n            \t\t\t\t),\n\t\t\t\t\tvalue: 5.3,\n\t\t\t\t\tabbrev: 'Fo',\n\t\t\t\t\tinitial: [{s:1,p:25},{s:-1,p:44}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t16: {\n\t\t\t\t\tname: 'dragon',\n\t\t\t\t\taspect: 'fr-mdd',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n            \t\t\t\tthis.cbQueenGraph(geometry,confine),\n            \t\t\t\tthis.cbKnightGraph(geometry,confine)\n            \t\t\t\t),\n\t\t\t\t\tvalue: 13.5,\n\t\t\t\t\tabbrev: 'Dr',\n\t\t\t\t\tinitial: [{s:1,p:26},{s:-1,p:45}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t15: {\n\t\t\t\t\tname: 'spider',\n\t\t\t\t\taspect: 'fr-spider',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n            \t\t\t\tthis.cbShortRangeGraph(geometry,\n            \t\t\t\t\t\t[\n            \t\t\t\t\t\t [-1,-2],[0,-2],[1,-2],[-1,2],[0,2],[1,2],\n            \t\t\t\t\t\t [-2,-1],[-2,0],[-2,1],[2,-1],[2,0],[2,1]\n            \t\t\t\t\t\t ],confine),\n            \t\t\t\tthis.cbLongRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]],confine,null,2)\n            \t\t\t\t),\n\t\t\t\t\tvalue: 5.1,\n\t\t\t\t\tabbrev: 'Sp',\n\t\t\t\t\tinitial: [{s:1,p:27},{s:-1,p:46}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t13: {\n\t\t\t\t\tname: 'unicorn',\n\t\t\t\t\taspect: 'fr-unicorn',\n\t\t\t\t\tgraph : this.cbShortRangeGraph(geometry,\n\t            \t\t\t[\n\t            \t\t\t [-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2],\n\t            \t\t\t [-1,-3],[-3,-1],[-3,1],[-1,3],[1,3],[3,1],[3,-1],[1,-3]\n\t            \t\t\t ],confine),\n\t\t\t\t\tvalue: 4.6,\n\t\t\t\t\tabbrev: 'U',\n\t\t\t\t\tinitial: [{s:1,p:28},{s:-1,p:47}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t12: {\n\t\t\t\t\tname: 'hawk',\n\t\t\t\t\taspect: 'fr-eagle',\n\t\t\t\t\tgraph : this.cbShortRangeGraph(geometry,\n\t            \t\t\t[\n\t            \t\t\t [-2,-2],[-2,0],[-2,2],[0,2],[2,2],[2,0],[2,-2],[0,-2],\n\t            \t\t\t [-3,-3],[-3,0],[-3,3],[0,3],[3,3],[3,0],[3,-3],[0,-3]\n\t            \t\t\t ],confine),\n\t\t\t\t\tvalue: 2.3,\n\t\t\t\t\tabbrev: 'H',\n\t\t\t\t\tinitial: [{s:1,p:33},{s:-1,p:51}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t10: {\n\t\t\t\t\tname: 'elephant',\n\t\t\t\t\taspect: 'fr-elephant',\n\t\t\t\t\tgraph : this.cbShortRangeGraph(geometry,\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t [1,1],[-1,1],[1,-1],[-1,-1],\n\t\t\t\t\t\t\t [0,1],[0,-1],[1,0],[-1,0],\n\t\t\t\t\t\t\t [-2,-2],[2,2],[-2,2],[2,-2],\n\t\t\t\t\t\t\t [-2,0],[2,0],[0,2],[0,-2]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t confine),\n\t\t\t\t\tvalue: 4.5,\n\t\t\t\t\tabbrev: 'E',\n\t\t\t\t\tinitial: [{s:1,p:34},{s:-1,p:52}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t17: {\n\t\t\t\t\tname: 'chancellor',\n\t\t\t\t\taspect: 'fr-marshall',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n            \t\t\t\tthis.cbRookGraph(geometry,confine),\n            \t\t\t\tthis.cbKnightGraph(geometry,confine)\n            \t\t\t\t),\n\t\t\t\t\tvalue: 8.5,\n\t\t\t\t\tabbrev: 'Ch',\n\t\t\t\t\tinitial: [{s:1,p:35},{s:-1,p:53}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t18: {\n\t\t\t\t\tname: 'archbishop',\n\t\t\t\t\taspect: 'fr-cardinal',\n\t\t\t\t\tgraph : this.cbMergeGraphs(geometry,\n            \t\t\t\tthis.cbBishopGraph(geometry,confine),\n            \t\t\t\tthis.cbKnightGraph(geometry,confine)\n            \t\t\t\t),\n\t\t\t\t\tvalue: 6.4,\n\t\t\t\t\tabbrev: 'Ar',\n\t\t\t\t\tinitial: [{s:1,p:36},{s:-1,p:54}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\t9: {\n\t\t\t\t\tname: 'cannon',\n\t\t\t\t\taspect: 'fr-cannon',\n\t\t\t\t\tgraph : this.cbShortRangeGraph(geometry,\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t [1,1],[-1,1],[1,-1],[-1,-1],\n\t\t\t\t\t\t\t [0,1],[0,-1],[1,0],[-1,0],\n\t\t\t\t\t\t\t [-2,1],[-2,0],[-2,-1],[2,1],[2,0],[2,-1],\n\t\t\t\t\t\t\t [0,2],[0,-2]\n\t\t\t\t\t\t\t ],\n\t\t\t\t\t\t\t confine),\n\t\t\t\t\tvalue: 4.6,\n\t\t\t\t\tabbrev: 'Ca',\n\t\t\t\t\tinitial: [{s:1,p:32},{s:-1,p:55}],\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\t\t\n        \n\t\t});\n\t\t\n\t\treturn {\n\t\t\t\n\t\t\tgeometry: geometry,\n\t\t\t\n\t\t\tpieceTypes: piecesTypes,\n\n\t\t\t// adding selected musketeer pieces to promotion choice\n\t\t\tpromote: function(aGame,piece,move) {\n\t\t\t\tif(piece.t==1)\n\t\t\t\t\treturn [0];\n\t\t\t\telse if(piece.t==3)\n\t\t\t\t\treturn [2];\n\t\t\t\telse if(piece.t==0 && geometry.R(move.t)==8)\n\t\t\t\t\treturn [4,5,6,7,this.type1,this.type2];\n\t\t\t\telse if(piece.t==2 && geometry.R(move.t)==1)\n\t\t\t\t\treturn [4,5,6,7,this.type1,this.type2];\n\t\t\t\treturn [];\n\t\t\t},\n\n\t\t\t// updating castle positions\n\t\t\tcastle: {\n\t\t\t\t\"12/8\": {k:[11,10],r:[9,10,11],n:\"O-O-O\"},\n\t\t\t\t\"12/15\": {k:[13,14],r:[14,13],n:\"O-O\"},\n\t\t\t\t\"68/64\": {k:[67,66],r:[65,66,67],n:\"O-O-O\"},\n\t\t\t\t\"68/71\": {k:[69,70],r:[70,69],n:\"O-O\"},\n\t\t\t},\n\t\t\t\n\t\t\tevaluate: function(aGame,evalValues,material) {\n\t\t\t\t// check lack of material to checkmate\n\t\t\t\tvar white=material[1].count;\n\t\t\t\tvar black=material[-1].count;\n\t\t\t\tif(!white[0] && !white[1] && !white[4] && !white[5] && !white[6] && !white[7]) { // white king single\n\t\t\t\t\tif(!black[2] && !black[3] && !black[6] && !black[7] && (black[4]+black[5]<2 || black[5]<2)) {\n\t\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!black[2] && !black[3] && !black[4] && !black[5] && !black[6] && !black[7]) { // black king single\n\t\t\t\t\tif(!white[0] && !white[1] && !white[6] && !white[7] && (white[4]+white[5]<2 || white[5]<2)) {\n\t\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check 50 moves without capture\n\t\t\t\tif(this.noCaptCount>=100) {\n\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\tthis.mWinner=JocGame.DRAW;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// motivate pawns to reach the promotion line\n\t\t\t\tvar distPromo=new Int8Array(3);\n\t\t\t\tvar height=geometry.height;\n\t\t\t\tvar pawns=material[1].byType[0],pawnsLength;\n\t\t\t\tif(pawns) {\n\t\t\t\t\tpawnsLength=pawns.length;\n\t\t\t\t\tfor(var i=0;i<pawnsLength;i++)\n\t\t\t\t\t\tswitch(height-geometry.R(pawns[i].p)) {\n\t\t\t\t\t\tcase 2: distPromo[0]++; break;\n\t\t\t\t\t\tcase 3: distPromo[1]++; break;\n\t\t\t\t\t\tcase 4: distPromo[2]++; break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpawns=material[-1].byType[2],pawnsLength;\n\t\t\t\tif(pawns) {\n\t\t\t\t\tpawnsLength=pawns.length;\n\t\t\t\t\tfor(var i=0;i<pawnsLength;i++)\n\t\t\t\t\t\tswitch(geometry.R(pawns[i].p)) {\n\t\t\t\t\t\tcase 1: distPromo[0]--; break;\n\t\t\t\t\t\tcase 2: distPromo[1]--; break;\n\t\t\t\t\t\tcase 3: distPromo[2]--; break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(distPromo[0]!=0)\n\t\t\t\t\tevalValues['distPawnPromo1']=distPromo[0];\n\t\t\t\tif(distPromo[1]!=0)\n\t\t\t\t\tevalValues['distPawnPromo2']=distPromo[1];\n\t\t\t\tif(distPromo[2]!=0)\n\t\t\t\t\tevalValues['distPawnPromo3']=distPromo[2];\n\t\t\t\t\n\t\t\t\t// motivate knights and bishops to deploy early\n\t\t\t\tvar minorPiecesMoved=0;\n\t\t\t\tfor(var t=4;t<=5;t++)\n\t\t\t\t\tfor(var s=1;s>=-1;s-=2) {\n\t\t\t\t\t\tvar pieces=material[s].byType[t];\n\t\t\t\t\t\tif(pieces)\n\t\t\t\t\t\t\tfor(var i=0;i<pieces.length;i++)\n\t\t\t\t\t\t\t\tif(pieces[i].m)\n\t\t\t\t\t\t\t\t\tminorPiecesMoved+=s;\n\t\t\t\t\t}\n\t\t\t\tif(minorPiecesMoved!=0) {\n\t\t\t\t\tevalValues['minorPiecesMoved']=minorPiecesMoved;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t};\n\t}\n\n\t\n\t/*\n\t * Model.Board.GenerateMoves:\n\t *   - handle setup phase : this.setupState\n\t *   \t. undefined : 1st white choice\n\t *   \t. setup1_0 : black choice (2nd piece or white choice cancel)\n\t *   \t. setup2_0 : white chooses 1st xtra piece placement\n\t *   \t. setup2_1 : black chooses 1st xtra piece placement\n\t *   \t. setup2_2 : white chooses 2nd xtra piece placement\n\t *   \t. setup2_3 : black chooses 2nd xtra piece placement\n\t */\n\t\t\n\tvar wStartPositions = [24,25,26,27,28,33,34,35,36,32]; // where available white extra pieces have been dropped on the starting board\n\tvar bStartPositions = [43,44,45,46,47,51,52,53,54,55]; // where available black extra pieces have been dropped on the starting board\n\tvar startupRowW = [0,1,2,3,4,5,6,7];\n\tvar startupRowB = [72,73,74,75,76,77,78,79];\n\tvar xtraPiece1StartPosW = 31;\n\tvar xtraPiece2StartPosW = 39;\n\tvar xtraPiece1StartPosB = 40;\n\tvar xtraPiece2StartPosB = 48;\n\t\n\tvar SuperModelBoardGenerateMoves=Model.Board.GenerateMoves;\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\tvar $this = this;  \n\t\tif (this.setupState===undefined) { // first time, white chooses first piece\t\t\t\n\n\t\t\tthis.mMoves=[{}];\n\t\t\twStartPositions.forEach(function(pos){\n\t\t\t\tif ($this.board[pos]>=0){\n\t\t\t\t\tvar piece = $this.pieces[$this.board[pos]] ;\n\t\t\t\t\t$this.mMoves.push({f:pos,t:xtraPiece1StartPosW});\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tif (this.setupState===\"setup1_0\"){// second time, black chooses same piece, or refuses\n\t\t\tthis.mMoves=[{}];\t\t\t\n\t\t\t// choose a 2nd piece \n            var emptyPos = -1;\n\t\t\tbStartPositions.forEach(function(pos){\n\t\t\t\tif ($this.board[pos]>=0){\n                    $this.mMoves.push({f:pos,t:xtraPiece2StartPosB});\n\t\t\t\t}else{\n                    emptyPos=pos;\n                }\n\t\t\t});\n            // or take first back to refuse\n            var pIdx = this.board[xtraPiece1StartPosB]; \n            this.mMoves.push({f:xtraPiece1StartPosB,t:emptyPos});\n\t\t\t\t\t\t\n\t\t\treturn;\n\t\t}\t\n\t\tif (this.setupState===\"setup2_0\"){// white chooses first xtra piece startup place \n\t\t\tthis.mMoves=[{}];\n\t\t\tstartupRowW.forEach(function(pos){\n\t\t\t\t$this.mMoves.push({f:xtraPiece1StartPosW,t:pos});\n\t\t\t});\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tif (this.setupState===\"setup2_1\"){// black chooses first xtra piece startup place \n\t\t\tthis.mMoves=[{}];\n\t\t\tstartupRowB.forEach(function(pos){\n\t\t\t\t$this.mMoves.push({f:xtraPiece1StartPosB,t:pos});\n\t\t\t});\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tif (this.setupState===\"setup2_2\"){// white chooses 2nd xtra piece startup place \n\t\t\tthis.mMoves=[{}];\n\t\t\t// first check if previous piece is behind the King or a rook\n\t\t\tvar prevPiece = -1 ;\n\t\t\tvar idx=startupRowW[0];\n\t\t\twhile (prevPiece < 0){\n\t\t\t\tif ($this.board[idx]>=0){\n\t\t\t\t\tprevPiece = $this.board[idx+8];\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tvar rk = this.pieces[prevPiece];\n\t\t\tvar pt1 = aGame.g.pTypes[rk.t].abbrev ;\t\t\t\t\t\n\t\t\tstartupRowW.forEach(function(pos){\n\t\t\t\tif ($this.board[pos]==-1){\n\t\t\t\t\tvar pt2 = aGame.g.pTypes[$this.pieces[$this.board[pos+8]].t].abbrev ;\n\t\t\t\t\tif ( ((pt1 == \"K\") && (pt2 == \"R\")) || ((pt1 == \"R\") && (pt2 == \"K\")) ){\n\t\t\t\t\t\t// can't place behind king and rook\n\t\t\t\t\t}else\n\t\t\t\t\t\t$this.mMoves.push({f:xtraPiece2StartPosW,t:pos});\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tif (this.setupState===\"setup2_3\"){// black chooses 2nd xtra piece startup place \n\t\t\tthis.mMoves=[{}];\n\t\t\t// first check if previous piece is behind the King or a rook\n\t\t\tvar prevPiece = -1 ;\n\t\t\tvar idx=startupRowB[0];\n\t\t\twhile (prevPiece < 0){\n\t\t\t\tif ($this.board[idx]>=0){\n\t\t\t\t\tprevPiece = $this.board[idx-8];\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tvar rk = this.pieces[prevPiece];\n\t\t\tvar pt1 = aGame.g.pTypes[rk.t].abbrev ;\t\t\t\t\t\n\t\t\tstartupRowB.forEach(function(pos){\n\t\t\t\tif ($this.board[pos]==-1){\n\t\t\t\t\tvar pt2 = aGame.g.pTypes[$this.pieces[$this.board[pos-8]].t].abbrev ;\n\t\t\t\t\tif ( ((pt1 == \"K\") && (pt2 == \"R\")) || ((pt1 == \"R\") && (pt2 == \"K\")) ){\n\t\t\t\t\t\t// can't place behind king and rook\n\t\t\t\t\t}else\n\t\t\t\t\t\t$this.mMoves.push({f:xtraPiece2StartPosB,t:pos});\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tSuperModelBoardGenerateMoves.apply(this,arguments); // call regular GenerateMoves method\n\t}\n\t\n\t/*\n\t * Model.Board.CopyFrom overriding to copy setupState property\n\t */\n\tvar SuperModelBoardCopyFrom = Model.Board.CopyFrom;\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tSuperModelBoardCopyFrom.apply(this,arguments);\n\t\tthis.setupState = aBoard.setupState;\n\t\tthis.type1 = aBoard.type1 ;\n\t\tthis.type2 = aBoard.type2 ;\n\t\tthis.bFirstDiplay = aBoard.bFirstDiplay ;\n\t\tthis.bXtraPiecesRemoved = aBoard.bXtraPiecesRemoved ;\n\t}\n\t\n\t/*\n\t * Model.Board.Evaluate overriding: in setup phase, no evaluation \n\t */\n\tvar SuperModelBoardEvaluate = Model.Board.Evaluate;\n\tModel.Board.Evaluate = function(aGame) {\n\t\tif(this.setupState===undefined || this.setupState!=\"done\")\n\t\t\treturn;\n\t\tSuperModelBoardEvaluate.apply(this,arguments);\n\t}\n\t\n\t\n\tModel.Board.CheckXtraPiecesEntrance = function(aGame,pos){\n\t\t// check if xtra pieces have to enter the game\n\t\tif ((pos > 7) && (pos < 16)){\t\t\t\t\n\t\t\tif (this.board[pos-8]>=0){\n\t\t\t\tthis.board[pos]=this.board[pos-8];\n\t\t\t\tthis.board[pos-8]=-1;\n\t\t\t\tthis.pieces[this.board[pos]].p = pos ; \n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.board[pos],pos);\n\t\t\t}\n\t\t}\n\t\tif ((pos > 63) && (pos < 72)){\t\t\t\t\n\t\t\tif (this.board[pos+8]>=0){\n\t\t\t\tthis.board[pos]=this.board[pos+8];\n\t\t\t\tthis.board[pos+8]=-1;\n\t\t\t\tthis.pieces[this.board[pos]].p = pos ; \n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.board[pos],pos);\n\t\t\t}\n\t\t}\n\t}\t\n\n\t/*\n\t * Model.Board.ApplyMove overriding: setup phase and king special move\n\t */\n\tvar SuperModelBoardApplyMove=Model.Board.ApplyMove;\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\tvar $this = this;\n\t\tif(this.setupState===undefined){\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n            // select same piece for black\n            bStartPositions.forEach(function(pos) {\n                if($this.board[pos]>=0){\n                    if($this.pieces[$this.board[xtraPiece1StartPosW]].t == $this.pieces[$this.board[pos]].t){\n                        var pIndex=$this.board[pos];\n                        $this.board[pos]=-1;\n                        $this.board[xtraPiece1StartPosB]=pIndex;\n                        $this.pieces[pIndex].p=xtraPiece1StartPosB;\n                    }\n                }\n            });\n\t\t\tthis.setupState=\"setup1_0\";\n\t\t}\n\t\telse if(this.setupState==\"setup1_0\") {\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\t// default values if players do not agree\n\t\t\tthis.type1 = DEFAULT_TYPE1 ; \n\t\t\tthis.type2 = DEFAULT_TYPE2 ; \n\t\t\tif(move.t==xtraPiece2StartPosB){\n\t\t\t\t// selection agreed\n\t\t\t\t// get xtra pieces types\n\t\t\t\tthis.type1 = this.pieces[this.board[xtraPiece1StartPosW]].t;\n\t\t\t\tthis.type2 = this.pieces[this.board[xtraPiece2StartPosB]].t;\n\t\t\t}else{\n\t\t\t\t// selection refused\n\t\t\t}\n\t\t\t// remove unused pieces from board\n\t\t\tif ($this.bXtraPiecesRemoved===undefined){\n                var positionsToBeScaned = wStartPositions.concat(bStartPositions).concat([xtraPiece1StartPosW,xtraPiece2StartPosW,xtraPiece1StartPosB,xtraPiece2StartPosB]);\n\t\t\t\tpositionsToBeScaned.forEach(function(pos) {\n\t\t\t\t\tif($this.board[pos]>=0){\n\t\t\t\t\t\tvar pIndex=$this.board[pos];\n\t\t\t\t\t\tif (pIndex>=0){\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$this.board[pos]=-1;\n\t\t\t\t\t\t\t$this.pieces[pIndex].p=-1;\n\t\t\t\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",pIndex,pos);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t$this.bXtraPiecesRemoved = true;\n\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t// setup 2 xtras pieces for W and B\n\t\t\tfor (var idx in this.pieces){\n\t\t\t\tvar myPiece = this.pieces[idx];\n\t\t\t\tif ((myPiece.t==this.type1) || (myPiece.t==this.type2)){\n\t\t\t\t\tconsole.log(\"select piece\",myPiece);\n\t\t\t\t\tif ((myPiece.t==this.type1) && (myPiece.s==1)) {\n\t\t\t\t\t\tmyPiece.p = xtraPiece1StartPosW ;\n\t\t\t\t\t\tthis.board[xtraPiece1StartPosW] = myPiece.i;\n\t\t\t\t\t}\n\t\t\t\t\tif ((myPiece.t==this.type2) && (myPiece.s==1)) {\n\t\t\t\t\t\tmyPiece.p = xtraPiece2StartPosW ;\n\t\t\t\t\t\tthis.board[xtraPiece2StartPosW] = myPiece.i;\n\t\t\t\t\t}\n\t\t\t\t\tif ((myPiece.t==this.type1) && (myPiece.s==-1)) {\n\t\t\t\t\t\tmyPiece.p = xtraPiece1StartPosB ;\n\t\t\t\t\t\tthis.board[xtraPiece1StartPosB] = myPiece.i;\n\t\t\t\t\t}\n\t\t\t\t\tif ((myPiece.t==this.type2) && (myPiece.s==-1)) {\n\t\t\t\t\t\tmyPiece.p = xtraPiece2StartPosB ;\n\t\t\t\t\t\tthis.board[xtraPiece2StartPosB] = myPiece.i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setupState=\"setup2_0\"; // choose start positions for xtra pieces \n            \n\t\t}\n\t\telse if(this.setupState==\"setup2_0\") {\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\tthis.setupState=\"setup2_1\"; // choose start positions for xtra pieces \n\t\t}\n\t\telse if(this.setupState==\"setup2_1\") {\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\tthis.setupState=\"setup2_2\"; // choose start positions for xtra pieces \n\t\t}\n\t\telse if(this.setupState==\"setup2_2\") {\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\tthis.setupState=\"setup2_3\"; // choose start positions for xtra pieces \n\t\t}\n\t\telse if(this.setupState==\"setup2_3\") {\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\tthis.setupState=\"done\"; // choose start positions for xtra pieces \n\t\t}\n\t\telse{\t\t\t\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t\t\t// check capture => capture xtra piece at the same time if there is one\n\t\t\tif(move.c){\n\t\t\t\tvar pos = move.t;\n\t\t\t\tif ((pos > 7) && (pos < 16)){\n\t\t\t\t\tif (this.board[pos-8]>=0){\n\t\t\t\t\t\tvar pIndex = this.pieces[this.board[pos-8]].i;\n\t\t\t\t\t\tthis.pieces[this.board[pos-8]].p = -1 ;\n\t\t\t\t\t\tthis.board[pos-8]=-1;\n\t\t\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",pIndex,pos-8);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif ((pos > 63) && (pos < 72)){\n\t\t\t\t\tif (this.board[pos+8]>=0){\n\t\t\t\t\t\tvar pIndex = this.pieces[this.board[pos+8]].i;\n\t\t\t\t\t\tthis.pieces[this.board[pos+8]].p = -1 ;\n\t\t\t\t\t\tthis.board[pos+8]=-1;\n\t\t\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",pIndex,pos+8);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tthis.CheckXtraPiecesEntrance(aGame,move.f);\n            if (move.cg){\n                this.CheckXtraPiecesEntrance(aGame,move.cg);\n            }\n\t\t}\n\t}\n\t/*\n\t * \n\t * Model.Move.ToString overriding for setup notation\n\t */\n\tvar SuperModelMoveToString = Model.Move.ToString;\n\tModel.Move.ToString = function() {\n\t\tif(this.f===undefined) {\n\t\t\tif(this.setup===undefined)\n\t\t\t\treturn \"--\";\n\t\t\telse\n\t\t\t\treturn \"#\"+this.setup;\n\t\t}\n\t\treturn SuperModelMoveToString.apply(this,arguments);\n\t}\n\tvar SuperApplyCastle = Model.Board.cbApplyCastle;\n\tModel.Board.cbApplyCastle = function(aGame,move,updateSign) {\n\t\treturn SuperApplyCastle.apply(this,arguments);\n\t}\n\t/*\n\t * \n\t * Model.Board.CompactMoveString overriding to help reading PJN game transcripts\n\t */\n\tvar SuperModelBoardCompactMoveString = Model.Board.CompactMoveString; \n\tModel.Board.CompactMoveString = function(aGame,aMove,allMoves) {\n\t\tif(typeof aMove.ToString!=\"function\") // ensure proper move object, if necessary\n\t\t\taMove=aGame.CreateMove(aMove);\n\t\tif (this.setupState===undefined)\n            {                \n                var p = this.pieces[this.board[aMove.f]];\n                return \"W1=\"+aGame.g.pTypes[p.t].abbrev;    \n            }\n\t\tif (this.setupState==\"setup1_0\")\n            {                \n                var p = this.pieces[this.board[aMove.f]];\n                return \"B2=\"+aGame.g.pTypes[p.t].abbrev;    \n            }\n\t\tif (this.setupState!=\"done\")\n            {                \n                var p = this.pieces[this.board[aMove.f]];\n                return aGame.g.pTypes[p.t].abbrev+\"^\"+geometry.PosName(aMove.t);   \n            }\n            \n        if (this.setupState!=\"done\")\n\t\t\treturn aMove.ToString();\n\t\treturn SuperModelBoardCompactMoveString.apply(this,arguments);\n\t}\n\n\t/*\n\t * Model.Board.StaticGenerateMoves overriding to prevent using AI during the setup phase\n\t */\n\n\tModel.Board.StaticGenerateMoves = function(aGame) {\n\t\tvar $this = this ;\n\t\t\n\t\tfunction isItOkRegardingKingRookException(pos,bWhite){\t\t\t\n\t\t\t// first check if previous piece is behind the King or a rook\n\t\t\tvar prevPiece = -1 ;\n\t\t\tvar row=bWhite?startupRowW:startupRowB;\n\t\t\tvar idx=row[0];\n\t\t\twhile (prevPiece < 0){\n\t\t\t\tif ($this.board[idx]>=0){\n\t\t\t\t\tprevPiece = bWhite?$this.board[idx+8]:$this.board[idx-8];\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tvar rk = $this.pieces[prevPiece];\n\t\t\tvar pt1 = aGame.g.pTypes[rk.t].abbrev ;\t\t\t\t\t\n\n\t\t\tvar pt2 = aGame.g.pTypes[$this.pieces[bWhite?$this.board[pos+8]:$this.board[pos-8]].t].abbrev ;\n\t\t\tif ( ((pt1 == \"K\") && (pt2 == \"R\")) || ((pt1 == \"R\") && (pt2 == \"K\")) ){\n\t\t\t\t// can't place behind king and rook\n\t\t\t\treturn false;\n\t\t\t}else\n\t\t\t\treturn true;\t\t\t\t\t\n\t\t}\n\n\t\t\n\t\tfunction getAnAvailablePiecePos(positions,bFree){\n\t\t\tfunction random() {\n\t\t\t\tvar d = new Date();\n\t\t\t\tvar seed = d.getTime(); \n\t\t\t    var x = Math.sin(seed++) * 10000;\n\t\t\t    return x - Math.floor(x);\n\t\t\t}\n\t\t\tvar pos = -1 ;\n\t\t\twhile (pos < 0){\n\t\t\t\tvar r = Math.floor(random()*positions.length);\n\t\t\t\tif (\t((!bFree) && ($this.board[positions[r]]>=0)) || \n\t\t\t\t\t\t((bFree) && ($this.board[positions[r]]<0)) )\n\t\t\t\t\tpos = positions[r] ;\n\t\t\t}\n\t\t\treturn pos;\n\t\t}\n\t\tif(this.setupState===undefined){\n\t\t\tvar f=getAnAvailablePiecePos(wStartPositions,false);\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:f,t:xtraPiece1StartPosW}))];\n\t\t}\n\t\tif(this.setupState==\"setup1_0\"){\n\t\t\t// accept white choice\n            var f=getAnAvailablePiecePos(bStartPositions,false);\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:f,t:xtraPiece2StartPosB}))];\n\t\t}\n\t\tif(this.setupState==\"setup2_0\"){\n\t\t\tvar t=getAnAvailablePiecePos(startupRowW,true);\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:xtraPiece1StartPosW,t:t}))];\n\t\t}\n\t\tif(this.setupState==\"setup2_1\"){\n\t\t\tvar t=getAnAvailablePiecePos(startupRowB,true);\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:xtraPiece1StartPosB,t:t}))];\n\t\t}\n\t\tif(this.setupState==\"setup2_2\"){\n\t\t\tvar t=getAnAvailablePiecePos(startupRowW,true);\n\t\t\twhile(!isItOkRegardingKingRookException(t,true)){\n\t\t\t\tt=getAnAvailablePiecePos(startupRowW,true);\n\t\t\t}\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:xtraPiece2StartPosW,t:t}))];\n\t\t}\n\t\tif(this.setupState==\"setup2_3\"){\n\t\t\tvar t=getAnAvailablePiecePos(startupRowB,true);\n\t\t\twhile(!isItOkRegardingKingRookException(t,false)){\n\t\t\t\tt=getAnAvailablePiecePos(startupRowB,true);\n\t\t\t}\t\t\t\n\t\t\treturn [aGame.CreateMove(aGame.CreateMove({f:xtraPiece2StartPosB,t:t}))];\n\t\t}\n\t\treturn null;\n\t}\t\t\n\t\n})();\n"],"file":"musketeer-chess-model.js"}